<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />

<style>
  body {
    font-family: sans-serif;
    padding: 1rem;
    max-width: 700px;
    margin: auto;
  }

  h1 {
    text-align: center;
  }

  label {
    display: flex;
    flex-direction: column;
    font-weight: 600;
    font-size: .9rem;
    margin-top: 1rem;
  }

  input, select, button {
    margin-top: .3rem;
    padding: .5rem;
    font-size: 1rem;
    width: 100%;
    box-sizing: border-box;
  }

  .result {
    background:#f5f5f5;
    padding:12px;
    margin-top:1rem;
    border-radius:6px;
    font-size:1.1rem;
  }

  @media (max-width: 600px) {
    form {
      grid-template-columns: 1fr;
    }
  }

  #preview-container {
    border:1px solid #ccc;
    width:100%;
    max-width:500px;
    padding:10px;
    margin-top:1rem;
    text-align:center;
  }

  .mat-pic-overlap {
    display: flex;          /* arrange children in a row */
    gap: 10px;              /* spacing between each pair */
    align-items: center;    /* vertically center labels and inputs */
  }
  
  .pair {
    display: flex;          /* label and input side by side */
    align-items: center;
    gap: 4px;               /* small space between label and input */
  }
  
  .mat-pic-overlap label {
    margin-right: 4px;      /* small space between label and input */
  }  

  input:disabled {
  background-color: #eee;
  color: #777;
}

</style>
    
<title>Picture Frame Size Calculator</title>
</head>

<body>

<h1>Picture Frame Size Calculator</h1>

<label>Preset Sizes
  <select id="preset">
    <option value="">-- Select a preset --</option>
    <option value="210x297|20|20|10|10|6">A4</option>
    <option value="297x420|30|30|15|15|6">A3</option>
    <option value="420x594|40|40|20|20|6">A2</option>
  </select>
</label>

<label for="overlapMode">Picture / Mat Overlap</label>
<select id="overlapMode">
  <option value="yes" selected>Yes</option>
  <option value="no">No</option>
</select>
<label for="PicMatOverlap">Overlap amount</label>
<input id="PicMatOverlap" type="number" value="5" min="0">

<label>Picture Width</label>
<input id="picW" placeholder="e.g. 300mm">

<label>Picture Height</label>
<input id="picH" placeholder="e.g. 500mm">

<label>Mat Width</label>
<input id="matW" placeholder="e.g. 50mm">

<label>Mat Height</label>
<input id="matH" placeholder="50mm">

<label>Mat/Picture Overlap:</label>
<div class="mat-pic-overlap">
  <div class="pair"><label>T</label><input id="matPicOT" value="5mm"></div>
  <div class="pair"><label>B</label><input id="matPicOB" value="5mm"></div>
  <div class="pair"><label>L</label><input id="matPicOL" value="5mm"></div>
  <div class="pair"><label>R</label><input id="matPicOR" value="5mm"></div>
</div>
  
<label>Framing Material Width</label>
<input id="fmW" placeholder="e.g. 40mm">

<label>Framing Material Height</label>
<input id="fmH" placeholder="40mm">

<label>Frame Inset (default 6mm)</label>
<input id="inset" value="6mm">

<div style="margin-top:1rem; display:flex; gap:10px;">
  <button id="resetBtn">Reset</button>
  <button id="copyBtn">Copy Results</button>
</div>

<div class="result">
    <div><b>Frame Width:</b> <span id="outW">—</span></div>
    <div><b>Frame Height:</b> <span id="outH">—</span></div>
</div>

<!-- Preview box -->
<h2>Preview</h2>
<div id="preview-container">
  <div id="frame-preview" style="background:#8b4513; position:relative; margin:auto;">
    <div id="mat-preview" style="background:#f5f5dc; position:absolute; top:0; left:0;">
      <div id="pic-preview" style="background:#add8e6; position:absolute; top:0; left:0;"></div>
    </div>
  </div>
</div>

<script>
// Converts "600mm", "60cm", "0.6m" -> mm
function toMM(val){
    if(!val) return 0;
    val = val.toString().trim().toLowerCase();
    if(val.endsWith("mm")) return parseFloat(val);
    if(val.endsWith("cm")) return parseFloat(val)*10;
    if(val.endsWith("m"))  return parseFloat(val)*1000;
    return parseFloat(val);
}

// Elements
let picWEl = document.getElementById("picW");
let picHEl = document.getElementById("picH");
let matWEl = document.getElementById("matW");
let matHEl = document.getElementById("matH");
let matPOTEl = document.getElementById("matPicOT");
let matPOBEl = document.getElementById("matPicOB");
let matPOLEl = document.getElementById("matPicOL");
let matPOREl = document.getElementById("matPicOR");  
let fmWEl  = document.getElementById("fmW");
let fmHEl  = document.getElementById("fmH");
let insetEl= document.getElementById("inset");
let presetEl = document.getElementById("preset");
const frameEl = document.getElementById("frame-preview");
const matEl   = document.getElementById("mat-preview");
const picEl   = document.getElementById("pic-preview");
let overlapMode = document.getElementById("overlapMode");
let overlapInput = document.getElementById("PicMatOverlap");
  
let scale = 0.5; // 0.5px per mm

// Main calculation
function calc() {
    let picW = toMM(picWEl.value) || 0;
    let picH = toMM(picHEl.value) || 0;
    let matW = toMM(matWEl.value) || 0;
    let matH = toMM(matHEl.value) || 0;
    let matPOT = toMM(matPOTEl.value) || 5;
    let matPOB = toMM(matPOBEl.value) || 5;
    let matPOL = toMM(matPOLEl.value) || 5;
    let matPOR = toMM(matPOREl.value) || 5;
    let fmW  = toMM(fmWEl.value) || 0;
    let fmH  = toMM(fmHEl.value) || 0;
    let inset= toMM(insetEl.value) || 6;

    // Only alert if a value is negative
    if(picW < 0 || picH < 0 || matW < 0 || matH < 0 || fmW < 0 || fmH < 0 || inset < 0){
        alert("Dimensions cannot be negative!");
        return;
    }
    // this doesn't factor - should be in toMM.  Could prob delete
    if (isNaN(picW) || isNaN(picH) || isNaN(matW) || isNaN(matH) || 
        isNaN(fmW) || isNaN(fmH) || isNaN(inset)) {
        alert("Inputs must be numeric!");
        return;
    }
  
    // Skip calculation if picture dimensions are zero (not filled yet)
    if(picW === 0 || picH === 0){
        document.getElementById("outW").textContent = "—";
        document.getElementById("outH").textContent = "—";
        frameEl.style.width = frameEl.style.height = "0px";
        matEl.style.width = matEl.style.height = "0px";
        picEl.style.width = picEl.style.height = "0px";
        return;
    }

    // calc it!
    // get the total width/height, then subtract the overlaps

    //frameWidth = (picW + (matW*2) + (fmW*2)) - ((inset*2) + matPOL + matPOR)
    //frameHeight = (picH + (matH*2) + (fmH*2)) - ((inset*2) + matPOT + matPOB)
  
    /*
    let frameWidth = 0;
    let frameHeight = 0;
    if (overlapMode.value === "yes") {
      frameWidth = (picW + (matW*2) + (fmW*2)) - ((inset*2) + matPOL + matPOR)
      frameHeight = (picH + (matH*2) + (fmH*2)) - ((inset*2) + matPOT + matPOB)
    }
    else {
      frameWidth = (picW + (matW*2) + (fmW*2)) - ((inset*2))
      frameHeight = (picH + (matH*2) + (fmH*2)) - ((inset*2))
    }
     */   
  
    const safe = v => Number.isFinite(v) ? v : 0;    
    let frameWidth =
      safe(picW) + safe(matW) * 2 + safe(fmW) * 2 - safe(inset) * 2;    
    let frameHeight =
      safe(picH) + safe(matH) * 2 + safe(fmH) * 2 - safe(inset) * 2;    
    if (overlapMode.value === "yes") {
      frameWidth -= safe(matPOL) + safe(matPOR);
      frameHeight -= safe(matPOT) + safe(matPOB);
    }

  
    document.getElementById("outW").textContent = Math.round(frameWidth)+" mm";
    document.getElementById("outH").textContent = Math.round(frameHeight)+" mm";

    // Update preview
    frameEl.style.width  = (frameWidth*scale)+"px";
    frameEl.style.height = (frameHeight*scale)+"px";
    frameEl.style.position = "relative";

    //matEl.style.width  = (((picW + (matW*2))-matPOL-matPOR)*scale)+"px";
    //matEl.style.height = (((picH + (matH*2))-matPOT-matPOB)*scale)+"px";
    
    //matEl.style.width  = ((picW + (matW*2))*scale)+"px";
    //matEl.style.height = ((picH + (matH*2))*scale)+"px";  


    let matWidth  = picW + (matW * 2);
    let matHeight = picH + (matH * 2);    
    if (overlapMode.value === "yes") {
      matWidth  -= (matPOL + matPOR);
      matHeight -= (matPOT + matPOB);
    }    
    matEl.style.width  = (matWidth  * scale) + "px";
    matEl.style.height = (matHeight * scale) + "px";

    matEl.style.top = ((fmH - inset)*scale)+"px"; 
    matEl.style.left = ((fmW - inset)*scale)+"px";
  
 
    //picEl.style.width  = (picW*scale)+"px";
    //picEl.style.height = (picH*scale)+"px";

/*
    if (overlapMode.value === "yes") {
      picEl.style.top = ((matH-matPOT)*scale)+"px";
      picEl.style.left = ((matW-matPOL)*scale)+"px";
    }
    else {
      picEl.style.top = (matH*scale)+"px";
      picEl.style.left = (matW*scale)+"px";      
    }
*/
  
    let picTop  = matH;
    let picLeft = matW;
    
    if (overlapMode.value === "yes") {
      picTop  -= matPOT;
      picLeft -= matPOL;
    }
    
    picEl.style.top  = (picTop  * scale) + "px";
    picEl.style.left = (picLeft * scale) + "px";


  
  /*
  console.log("Preview frame width: ", (frameWidth*scale)+"px");
  console.log("Preview frame height: ", (frameHeight*scale)+"px");
  console.log("Preview mat width: ", ((picW + matW*2)*scale)+"px");
  console.log("Preview mat height: ", ((picH + matH*2)*scale)+"px");
  console.log("Preview mat top: ", (fmH*scale - inset*scale)+"px");
  console.log("Preview mat left: ", (fmW*scale - inset*scale)+"px");
  console.log("Preview picture width: ", (picW*scale)+"px");
  console.log("Preview picture height: ", (picH*scale)+"px");
  console.log("Preview picture top: ", (matH*scale)+"px");
  console.log("Preview picture left: ", (matW*scale)+"px");
  */
  
};


// Local storage
function saveToLocalStorage() {
    localStorage.setItem("picW", picWEl.value);
    localStorage.setItem("picH", picHEl.value);
    localStorage.setItem("matW", matWEl.value);
    localStorage.setItem("matH", matHEl.value);
    localStorage.setItem("fmW", fmWEl.value);
    localStorage.setItem("fmH", fmHEl.value);
    localStorage.setItem("inset", insetEl.value);
    localStorage.setItem("preset", presetEl.value);
    localStorage.setItem("matPicOT", matPOTEl.value);
    localStorage.setItem("matPicOB", matPOBEl.value);
    localStorage.setItem("matPicOL", matPOLEl.value);
    localStorage.setItem("matPicOR", matPOREl.value);
}

function loadFromLocalStorage() {
    if(localStorage.getItem("picW")) picWEl.value = localStorage.getItem("picW");
    if(localStorage.getItem("picH")) picHEl.value = localStorage.getItem("picH");
    if(localStorage.getItem("matW")) matWEl.value = localStorage.getItem("matW");
    if(localStorage.getItem("matH")) matHEl.value = localStorage.getItem("matH");
    if(localStorage.getItem("fmW"))  fmWEl.value = localStorage.getItem("fmW");
    if(localStorage.getItem("fmH"))  fmHEl.value = localStorage.getItem("fmH");
    if(localStorage.getItem("inset")) insetEl.value = localStorage.getItem("inset");
    if(localStorage.getItem("preset")) presetEl.value = localStorage.getItem("preset");
    if(localStorage.getItem("matPicOT")) matPOTEl.value = localStorage.getItem("matPicOT");
    if(localStorage.getItem("matPicOB")) matPOBEl.value = localStorage.getItem("matPicOB");
    if(localStorage.getItem("matPicOL")) matPOLEl.value = localStorage.getItem("matPicOL");
    if(localStorage.getItem("matPicOR")) matPOREl.value = localStorage.getItem("matPicOR");
}

// Event listeners
document.querySelectorAll("input").forEach(el => {
    el.addEventListener("input", () => {
        saveToLocalStorage();
        calc();
    });
});

// Reset button
document.getElementById("resetBtn").addEventListener("click", () => {
    // Clear local storage
    localStorage.clear();
    
    // Clear inputs
    picWEl.value = '';
    picHEl.value = '';
    matWEl.value = '';
    matHEl.value = '';
    fmWEl.value = '';
    fmHEl.value = '';
    insetEl.value = '6mm';
    presetEl.value = '';
    
    // Reset output display
    document.getElementById("outW").textContent = "—";
    document.getElementById("outH").textContent = "—";

    // Reset preview
    frameEl.style.width = frameEl.style.height = "0px";
    matEl.style.width = matEl.style.height = "0px";
    picEl.style.width = picEl.style.height = "0px";
});

// Copy results
document.getElementById("copyBtn").addEventListener("click", () => {
    const pw = picWEl.value || "0mm";
    const ph = picHEl.value || "0mm";
    const mw = matWEl.value || "0mm";
    const mh = matHEl.value || "0mm";
    const fw = fmWEl.value || "0mm";
    const fh = fmHEl.value || "0mm";
    const inset = insetEl.value || "6mm"; // default inset if empty
    const totalW = document.getElementById("outW").textContent || "0 mm";
    const totalH = document.getElementById("outH").textContent || "0 mm";

    const txt = `Picture: ${pw} x ${ph}
Mat: ${mw} x ${mh}
Frame: ${fw} x ${fh}
Inset: ${inset}
Total Frame: W ${totalW} x H ${totalH}`;

    navigator.clipboard.writeText(txt).then(() => {
        alert("Results copied to clipboard!");
    }).catch(err => {
        console.error("Copy failed:", err);
        alert("Unable to copy results.");
    });
});


overlapMode.addEventListener("change", () => {
  if (overlapMode.value === "no") {
    overlapInput.value = 0;
    overlapInput.disabled = true;
    matPOTEl.disabled = true;
    matPOBEl.disabled = true;
    matPOLEl.disabled = true;
    matPOREl.disabled = true;    
  } else {
    overlapInput.disabled = false;
    matPOTEl.disabled = false;
    matPOBEl.disabled = false;
    matPOLEl.disabled = false;
    matPOREl.disabled = false;        
  }

  calc(); // keep your live recalculation
});
  

// Preset selection
presetEl.addEventListener("change", () => {
    if(!presetEl.value) return;
    const [pic, mat, frame, inset] = presetEl.value.split("|");
    const [pw, ph] = pic.split("x");
    picWEl.value = pw + "mm";
    picHEl.value = ph + "mm";
    matWEl.value = mat + "mm";
    matHEl.value = mat + "mm";
    fmWEl.value = frame + "mm";
    fmHEl.value = frame + "mm";
    insetEl.value = inset + "mm";
    saveToLocalStorage();
    calc();
});

// Load values and calculate on page load
window.addEventListener("DOMContentLoaded", () => {
    loadFromLocalStorage();
    calc();
});
</script>

</body>
</html>
